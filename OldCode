VERTEX
    # def incidentEdge(self):
    #     return self._incidentEdge

    # def setIncidentEdge(self, edge):
    #     self._incidentEdge = edge
    #     return edge

FACE
    # def setOuterComponent(self, edge):
    #     self._outerComponent = edge
    #     return edge

    # def setInnterComponent(self, edge):
    #     self._innerComponent = edge
    #     return edge
    
    # def innerComponent(self):
    #     return self._innerComponent

    # def outerComponent(self):
    #     return self._outerComponent

HALFEDGE
    # def origin(self):
    #     return self._origin

    # def twin(self):
    #     return self._twin

    # def incidentFace(self):
    #     return self._incidentFace

    # def next(self):
    #     return self._next

    # def prev(self):
    #     return self._prev
    
    # def setOrigin(self, origin):
    #     self.__origin = origin
    #     return self._origin

    # def setTwin(self, twin):
    #     self.__twin = twin
    #     return self._twin

    # def setIncidentFace(self, incidentFace):
    #     self.__incidentFace = incidentFace
    #     return self._incidentFace

    # def setNext(self, next):
    #     self.__next = next
    #     return self._next

    # def setPrev(self, prev):
    #     self.__prev = prev
    #     return self._prev

BINTREE
    # def left(self, node):
    #     return node.left()

    # def right(self, node):
    #     return node.right()

    # def parent(self, node):
    #     return node.parent()

    # def depth(self, node):
    #     return node.depth()

    # def version(self, node):
    #     return node.version()

    # def site(self, node):
    #     return node.site()

    # def event(self, node):
    #     return node.event()

    # def breakpoint(self, node):
    #     return node.breakpoint()

    # def halfedge(self, node):
    #     return node.halfedge()

NODE
    # def version(self):
    #     return self.version

    # def site(self):
    #     return self._site

    # def event(self):
    #     return self._event

    # def breakpoint(self):
    #     return self._breakpoint

    # def halfedge(self):
    #     return self._halfedge

    # def left(self):
    #     return self._left

    # def right(self):
    #     return self._right

    # def parent(self):
    #     return self._parent


BOUNDING BOX
    # def computeBounds(self):
    #     vertices = self._edgelist.vertices()
    #     if len(vertices) == 0:
    #         return [0,1,0,1]
    #     minX = float('inf')
    #     maxX = float('-inf')
    #     minY = float('inf')
    #     maxY = float('-inf')
    #     for v in vertices:
    #         if maxX < v._coordinates[0]:
    #             maxX = v._coordinates[0]
    #         if maxY < v._coordinates[1]:
    #             maxY = v._coordinates[1]
    #         if minX > v._coordinates[0]:
    #             minX = v._coordinates[0]
    #         if minY > v._coordinates[1]:
    #             minY = v._coordinates[1]

    #     return [minX, maxX, minY, maxY]


    FACES IN DCEL
    class Face:
    def __init__(self):
        self._outerComponent = None
        self._innerComponent = []



        self._faces = [] # in DCEL contructor

    def faces(self):
        return self._faces
    


NEXTLEAF
        if (successor._left == None) and (successor._right == None):
            return successor
        else:

PREVLEAF
        if (predessesor._left == None) and (predessesor._right == None):
            return predessesor
        else:

BINTREE - getting key of each node
    # def key(self, node, y):
    #     if node._version == 'arc':
    #         return node._site[0]
    #     else:
    #         i = self.intersect(node._breakpoint, y)
    #         if len(i) == 1:
    #             return i[0]
    #         else:
    #             return min(i[0], i[1])[0]


VORONOI - our old assumption about how the tree looks during circle events
    if self._status.isLeftChild(parent):
        grandparent._left = parent._left
        grandparent._breakpoint = [parent._breakpoint[0], grandparent._breakpoint[1]]
    else:
        grandparent._right = parent._right
        grandparent._breakpoint = [grandparent._breakpoint[0], parent._breakpoint[1]]


# return 'object: ' + repr(self) + ', origin: ' + str(self._origin) + ', dest: ' + str(self.dest()) + ', twin: ' + repr(self._twin)
# return 'origin: ' + str(self._origin) + ', dest: ' + repr(self.dest()) + ', next: ' + repr(self._next) + ', prev: ' + repr(self._prev)
# return 'origin: ' + str(self._origin) + ', dest: ' + str(self.dest()) + ', next: ' + repr(self._next) + ', prev: ' + repr(self._prev) + ', twin: ' + repr(self._twin)


BINTREE - check if all nodes are referencing children properly
    def checkYourself(self, node):
        print('yee')
        if node._left is not None:
            if node._left._parent != node:
                print('oh fuck')
            self.checkYourself(node._left)
        if node._right is not None:
            if node._right._parent != node:
                print('oh fuck')
            self.checkYourself(node._right)




BINTREE - prints all the nodes out
    def getNodes(self):
        l = []
        l = self.recurseAcc(l, self._root)
        return l

    def recurseAcc(self, l, n):
        l += [n]
        if n._left is not None:
            l = self.recurseAcc(l, n._left)
        if n._right is not None:
            l = self.recurseAcc(l, n._right)
        return l

